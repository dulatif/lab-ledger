# 2. Getting Started with Test Suites

## ğŸ¯ Learning Goal

Learn how to use the NestJS `Test` class to mock the Nest runtime environment for Unit Testing.

## ğŸ§  Concept

In a real NestJS app, the **IoC Container** creates classes and injects dependencies.
In a Unit Test, we want to isolate a **single class** (e.g., `CatsController`). We don't want to load the _entire_ application just to test one function.

NestJS provides a `Test` utility that allows you to create a "Mini Module" just for the test context.

## ğŸ’» Implementation

### 1. The Setup (`beforeEach`)

We use `beforeEach` to create a fresh module before every individual test.

```typescript
import { Test, TestingModule } from "@nestjs/testing";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

describe("CatsController", () => {
  let controller: CatsController;
  let service: CatsService;

  beforeEach(async () => {
    // ğŸ­ Create a mini-module
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CatsController],
      providers: [CatsService],
    }).compile(); // ğŸ§± Compile dependencies

    // ğŸ£ Get the instance from the container
    controller = module.get<CatsController>(CatsController);
    service = module.get<CatsService>(CatsService);
  });

  it("should be defined", () => {
    expect(controller).toBeDefined();
  });
});
```

## ğŸ§© Activity / Challenge

1.  Open any `.spec.ts` file generated by the CLI.
2.  Identify the `Test.createTestingModule` block.
3.  Try to comment out the `providers` array.
4.  Run the test. It should fail because Nest creates the Controller but doesn't know how to inject the Service!

## ğŸ”‘ Key Takeaways

- `Test.createTestingModule`: Mimics `@Module` decorator but for testing.
- `.compile()`: Bootstraps the module asynchronously.
- `.get<Type>(Token)`: Retrieves an instance from the test module.
- `beforeEach`: Ensures a clean state for every test.
