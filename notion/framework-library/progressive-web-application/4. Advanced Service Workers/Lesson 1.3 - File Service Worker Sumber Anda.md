# üí° AD01.3: Your Service Worker's Source of Truth

**Outline:**

- **The Heart of Your PWA (Presentation):** Introducing the custom service worker file (`sw.ts`).
- **Boilerplate and Imports (Practice):** Writing the essential first lines of code.
- **Bringing Precaching Back (Production):** Re-implementing precaching manually.

## üìò **Full Lesson Content**

### **Part 1: Presentation - The Heart of Your PWA**

Welcome to your service worker source file. In our case, it's `src/sw.ts`. This file is the new brain of your PWA's network operations. It's no longer a temporary file generated by a tool; it's a permanent, version-controlled part of your codebase.

What goes in this file?

- **Workbox Imports:** You'll import the specific Workbox modules you need, just like you import libraries in your React components.
- **Precaching:** You'll explicitly call the Workbox function to handle precaching.
- **Routing Logic:** You'll define custom routes to handle different types of requests (e.g., API calls, images, fonts).
- **Event Listeners:** You'll listen for service worker lifecycle events (`install`, `activate`), as well as functional events like `push` and `sync`.

Treat this file with the same care you'd treat your main application code. It's a living document that will evolve as your PWA's capabilities grow. This is where you architect reliability.

### **Part 2: Practice - Boilerplate and Imports**

Let's create the file and add the foundational code. First, create a new file at `src/sw.ts`.

Here is the essential boilerplate to get started. This code re-enables the precaching that `generateSW` used to do for us automatically.

```
// src/sw.ts

/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope;

import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';

// This is a placeholder for the list of files to be precached.
// The build tool will replace this with the actual file manifest.
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches from previous versions of the service worker.
cleanupOutdatedCaches();

// Optional: Add a listener for the 'install' event to see it in action.
self.addEventListener('install', (event) => {
  console.log('Service worker installing...');
});

// We must have a fetch listener, even a basic one, for the PWA to be installable.
self.addEventListener('fetch', (event) => {
  // We'll add routing logic here in the next lesson.
});
```

**Breaking it down:**

- `declare const self: ServiceWorkerGlobalScope;`: This provides TypeScript with the correct types for the global `self` object within a service worker context.
- `import { ... } from 'workbox-precaching'`: We are now explicitly importing the functions we need from Workbox's modules. Tree-shaking will ensure only the code we use gets bundled.
- `precacheAndRoute(self.__WB_MANIFEST)`: This is the critical line. `self.__WB_MANIFEST` is the magic variable that the `vite-plugin-pwa` (or other build tool) will find and replace with an array of all your assets (e.g., `{url: 'index.html', revision: '...'}, {url: 'app.js', revision: '...'}`). The `precacheAndRoute` function then takes that list and sets up all the necessary logic to serve those files from the cache.

## üß† **Real-World Case Study: "The Debugging Nightmare vs. The Source of Truth"**

- **Before (`generateSW`):** A developer is facing a weird caching bug. An old version of a CSS file is being served. They look in their `dist` folder and find the `sw.js` file generated by Workbox. It's minified, complex, and thousands of lines long. They have no idea how it works or how to debug it. They are debugging a compiled artifact, which is a recipe for frustration.
- **After (`injectManifest`):** The same developer suspects a caching issue. They open `src/sw.ts`. The file is clean, well-commented, and contains only the logic they wrote. They can add `console.log` statements, step through the code in the browser's debugger, and easily pinpoint the issue in their routing logic. They are debugging their _own source code_, giving them full visibility and control.

## ü§î **Reflective Questions**

1. What is `self.__WB_MANIFEST` and who creates it?
2. Why is it better to import specific modules like `workbox-precaching` instead of a single, monolithic Workbox library?
3. If you add a new `.png` image to your project, what do you need to do in `src/sw.ts` to make sure it gets precached? (Hint: The answer might be "nothing").

## üìö **Further Reading**

- **Tooling:** [Official Vite PWA `injectManifest` example](https://www.google.com/search?q=https://github.com/vite-pwa/vite-plugin-pwa/tree/main/examples/inject-manifest-ts)
- **Workbox Docs:** [`precacheAndRoute` Explained](https://www.google.com/search?q=https://developer.chrome.com/docs/workbox/modules/workbox-precaching/%23precache-and-route)
- **Web.dev:** [The Service Worker Lifecycle](https://web.dev/articles/service-worker-lifecycle) (Essential for understanding events like `install` and `activate`).

## üìù **Mini Task (Production)**

Let's get your service worker running.

1. In your project, create the new file `src/sw.ts`.
2. Copy the boilerplate code from the "Practice" section into this new file.
3. Run your build command (`npm run build`). This time, it should succeed because the build tool will find your `src/sw.ts` file.
4. Preview your production build (`npm run preview`).
5. Open your browser's DevTools, go to the "Application" tab, and then "Service Workers." You should see your service worker listed as "activated and is running." Check the console; you should see your "Service worker installing..." message. Congratulations, you are now in manual control.